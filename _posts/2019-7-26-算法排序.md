---
layout: post
title: "算法排序"
categories: 算法
tags: 算法
author: 百味皆苦
music-id: 2602106546
---

* content
{:toc}
### 选择排序

#### 原理

- 每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。也就是：每一趟在n-i+1(i=1，2，…n-1)个记录中选取关键字最小的记录作为有序序列中第i个记录
- 基于此思想的算法主要有[简单选择排序](http://baike.so.com/doc/5992150-6205119.html)、树型选择排序和[堆排序](http://baike.so.com/doc/1008529-1066354.html)。（这里只介绍常用的简单选择排序）

#### 基本思想

- 简单选择排序的基本思想：给定数组：int[] arr={里面n个数据}；
- 第1趟排序，在待排序数据arr[1]~arr[n]中选出最小的数据，将它与arrr[1]交换；
- 第2趟，在待排序数据arr[2]~arr[n]中选出最小的数据，将它与r[2]交换；
- 以此类推，第i趟在待排序数据arr[i]~arr[n]中选出最小的数据，将它与r[i]交换，直到全部排序完成

#### 举例

- 数组 int[] arr={5,2,8,4,9,1};

- 第一趟排序： 原始数据：5  2  8  4  9  1

  最小数据1，把1放在首位，也就是1和5互换位置，

  排序结果：1  2  8  4  9  5

- 第二趟排序：

  第1以外的数据{2  8  4  9  5}进行比较，2最小，

  排序结果：1  2  8  4  9  5

- 每一趟排序获得最小数的方法：for循环进行比较，定义一个第三个变量temp，首先前两个数比较，把较小的数放在temp中，然后用temp再去跟剩下的数据比较，如果出现比temp小的数据，就用它代替temp中原有的数据

#### 代码实现

```java
//选择排序
public class SelectionSort {
    public static void main(String[] args) {
        int[] arr={1,3,2,45,65,33,12};
        System.out.println("交换之前：");
        for(int num:arr){
            System.out.print(num+" ");
        }        
        //选择排序的优化
        for(int i = 0; i < arr.length - 1; i++) {// 做第i趟排序
            int k = i;
            for(int j = k + 1; j < arr.length; j++){// 选最小的记录
                if(arr[j] < arr[k]){ 
                    k = j; //记下目前找到的最小值所在的位置
                }
            }
            //在内层循环结束，也就是找到本轮循环的最小的数以后，再进行交换
            if(i != k){  //交换a[i]和a[k]
                int temp = arr[i];
                arr[i] = arr[k];
                arr[k] = temp;
            }    
        }
        System.out.println();
        System.out.println("交换后：");
        for(int num:arr){
            System.out.print(num+" ");
        }
    }

}
```

#### 时间复杂度

- 简单选择排序的比较次数与序列的初始排序无关。 假设待排序的序列有 N 个元素，则比较次数永远都是N (N - 1) / 2。而移动次数与序列的初始排序有关。当序列正序时，移动次数最少，为 0。当序列反序时，移动次数最多，为3N (N - 1) /  2。
- 简单排序的时间复杂度为 O(N2)



### 冒泡排序

- 相邻元素前后交换、把最大的排到最后
- 时间复杂度 O(n²)

#### 思路1

- 从左往右，两两比较，把最小的数往右移动

- 假如有几个数字int score[] = {67, 69, 75, 88};  按照从大到小排序
- score[j] 和 score[j+1] 比较 如果 前者比后者小，把前者和后者调换顺序，两两调换后一轮下来 最小的会被排到最后去
- 每一轮j都从0开始，当i轮排序，就有最后面的i个数字因为他是最小的，所以后面的每轮都不用理他了，也就是 score.length-1-i  往后的数不用管了，如上，第一轮有4个数字 i为0 ，那么score.length-1-i  为3，也就是下标是3以后的可以不用管，3往后没有数字，所以第一轮所有的数字都要参加比较，第二轮I=1  score.length-1-i  为2 也就是说 下标2后面的 下标为3的数字不用比了，因为两两比较后，67会到 score[3]

```
score[] = {67, 69, 75, 88}

第一次：67<69--->{69,67,75,88}--->67<75--->{69,75,67,88}-->67<88-->{69,75,88,67}

第二次：69<75-->{75,69,88,67}-->69<88-->{75,88,69,67}

第三次：75<88-->{88,75,69,67}
```



```java
for(int i =0;i < score.length - 1;i++)
        {
            for(int j = 0;j <  score.length - 1-i;j++)// j开始等于0，
            {
                if(score[j] < score[j+1])
                {
                    int temp = score[j];
                    score[j] = score[j+1];
                    score[j+1] = temp;
                }
            }
        }
```

#### 思路2

- 用88 和 75 比较，在和69 比较 在和 67 比较，发现88是最大的，吧他排到第一位(index=0的位置)，然后i=1,也就是第二轮，就不用看下标为0的88了因为他是老大，然后接着比较。
- 从右往左，两两比较，把最大的数往左移动

```
score[] = {67, 69, 75, 88}

第一次：75<88-->{67,69,88,75}-->69<88-->{67,88,69,75}-->67<88-->{88,67,69,75}

第二次:69<75-->{88,67,75,69}-->67<75-->{88,75,67,69}

第三次：67<69-->{88,75,69,67}
```



```java
for(int i =0;i < score.length - 1;i++)
        {
            for(int j = (score.length - 2);j >= i;j--)
            {
                if(score[j] < score[j+1])
                {
                    int temp = score[j];
                    score[j] = score[j+1];
                    score[j+1] = temp;
                }
            }
        }
```



### 插入排序

#### 原理

-  插入排序是基于比较的排序。所谓的基于比较，就是通过比较数组中的元素，看谁大谁小，根据结果来调整元素的位置。
- 有两种基本的操作：①比较操作； ②交换操作
- 对于交换操作，可以优化成移动操作，即不直接进行两个元素的交换，还是用一个枢轴元素(tmp)将当前元素先保存起来，然后执行移动操作，待确定了最终位置后，再将当前元素放入合适的位置。**因为，交换操作需要三次赋值，而移动操作只需要一次赋值**！

#### 分析

- 插入排序算法有种递归的思想在里面，它由N-1趟排序组成。初始时，只考虑数组下标0处的元素，只有一个元素，显然是有序的
- 然后第一趟 对下标 1 处的元素进行排序，保证数组[0,1]上的元素有序；
- 第二趟 对下标 2 处的元素进行排序，保证数组[0,2]上的元素有序；
- 第N-1趟对下标 N-1 处的元素进行排序，保证数组[0,N-1]上的元素有序，也就是整个数组有序了
- 它的递归思想就体现在：当对位置 i 处的元素进行排序时，[0,i-1]上的元素一定是已经有序的了

#### 举例

```
arr = {34,8,64,51};

第一次：p=1,tmp=8-->j=1,34>8-->{34,34,64}-->j=0-->{8,34,64,51}

第二次：p=2,tmp=64-->j=2,8<64-->{8,34,64,51}

第三次：p=3,tmp=51-->j=3,64>51-->{8,34,64,64}-->j=2,51>34-->{8,34,51,64}
```



#### 实现

```java
public class InsertSort{
    
    public static <T extends Comparable<? super T>> void insertSort(T[] a){
        for(int p = 1; p < a.length; p++)
        {
            T tmp = a[p];//保存当前位置p的元素，其中[0,p-1]已经有序
            int j;
            //for(j = p; j > 0 && tmp<(a[j-1]); j--)
            for(j = p; j > 0 && tmp.compareTo(a[j-1]) < 0; j--)
            {
                    a[j] = a[j-1];//后移一位
            }
            a[j] = tmp;//插入到合适的位置
        }
    }
    
    //for test purpose
    public static void main(String[] args) {
        Integer[] arr = {34,8,64,51,32,21};
        insertSort(arr);
        for (Integer i : arr) {
            System.out.print(i + " ");
        }
    }
}
```

#### 复杂度

- ①插入排序的时间复杂度 就是判断比较次数有多少，而比较次数与 待排数组的初始顺序有关，当待排数组有序时，没有移动操作（第8行for不成立），此时复杂度为O(N)，当待排数组是逆序时，比较次数达到最大--对于下标 i 处的元素，需要比较 i-1 次。总的比较次数：1+2+...+N-1 ，故时间复杂度为O(N^2)
- ①可以看出，算法中只用到了一个临时变量（第6行），故空间复杂度为O(1)



### 快速排序

#### 原理

- 快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。
- 这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了

#### 举例

```
{6  1  2  7  9  3  4  5 10  8}设基准数为6

这里可以用两个变量i和j，分别指向序列最左边和最右边，j向左移动寻找小于基准数的数，i向右移动寻找大于基准数的数。

首先哨兵j开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵j先出动，这一点非常重要，j停在5，i停在7，交换，｛6  1  2  5  9  3  4  7 10  8｝

继续寻找，j停在4，i停在9，交换，｛6  1  2  5  4  3  9  7 10  8｝

继续，i，j都停在3，此时和基准数交换，｛3  1  2  5  4  6  9  7 10  8｝，6左边全部≤6，右边全部≥6

在6的左边和右边采用同样的方法，递归，最终｛1  2  3  4  5  6  7  8 9  10｝
```

#### 实现

```java
public class QuickSort{
    
    public static void quickSort(Integer[] a,int left,int right)
    {
            int i,j,t,temp; 
            if(left>right) 
               return; 

            temp=a[left]; //temp中存的就是基准数 
            i=left; 
            j=right; 
            while(i!=j) 
            { 
                   //顺序很重要，要先从右边开始找 
                   while(a[j]>=temp && i<j) 
                            j--; 
                   //再找右边的 
                   while(a[i]<=temp && i<j) 
                            i++; 
                   //交换两个数在数组中的位置 
                   if(i<j) 
                   { 
                            t=a[i]; 
                            a[i]=a[j]; 
                            a[j]=t; 
                   } 
            } 
            //最终将基准数归位 
            a[left]=a[i]; 
            a[i]=temp; 

            quickSort(a,left,i-1);//继续处理左边的，这里是一个递归的过程 
            quickSort(a,i+1,right);//继续处理右边的 ，这里是一个递归的过程 
    }
    
    //for test purpose
    public static void main(String[] args) {
        Integer[] arr = {6,1,2,7,9,3,4,5,10,8};
        quickSort(arr,0,arr.length-1); //快速排序调用 
        for (Integer i : arr) {
            System.out.print(i + " ");
        }
    }
}
```

#### 复杂度

- 快速排序的最差时间复杂度和冒泡排序是一样的都是O(N2)，它的平均时间复杂度为O(NlogN)。



### 归并排序

#### 原理

- 归并排序（MERGE-SORT）是利用**归并**的思想实现的排序方法，该算法采用经典的**分治**（divide-and-conquer）策略（分治法将问题**分**(divide)成一些小的问题然后递归求解，而**治(conquer)**的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)

#### 举例

![](https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/guibing.png)

![](https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/guibing2.png)



#### 实现

```java
public class MergeSort {
    public static void main(String []args){
        int []arr = {9,8,7,6,5,4,3,2,1};
        sort(arr);
        System.out.println(Arrays.toString(arr));
    }
    public static void sort(int []arr){
        int []temp = new int[arr.length];//在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间
        sort(arr,0,arr.length-1,temp);
    }
    private static void sort(int[] arr,int left,int right,int []temp){
        if(left<right){
            int mid = (left+right)/2;
            sort(arr,left,mid,temp);//左边归并排序，使得左子序列有序
            sort(arr,mid+1,right,temp);//右边归并排序，使得右子序列有序
            merge(arr,left,mid,right,temp);//将两个有序子数组合并操作
        }
    }
    private static void merge(int[] arr,int left,int mid,int right,int[] temp){
        int i = left;//左序列指针
        int j = mid+1;//右序列指针
        int t = 0;//临时数组指针
        while (i<=mid && j<=right){
            if(arr[i]<=arr[j]){
                temp[t++] = arr[i++];
            }else {
                temp[t++] = arr[j++];
            }
        }
        while(i<=mid){//将左边剩余元素填充进temp中
            temp[t++] = arr[i++];
        }
        while(j<=right){//将右序列剩余元素填充进temp中
            temp[t++] = arr[j++];
        }
        t = 0;
        //将temp中的元素全部拷贝到原数组中
        while(left <= right){
            arr[left++] = temp[t++];
        }
    }
}
```



####  复杂度

- 每次合并操作的平均时间复杂度为O(n)，而完全二叉树的深度为|log2n|。
- 总的平均时间复杂度为O(nlogn)。而且，归并排序的最好，最坏，平均时间复杂度均为O(nlogn)。