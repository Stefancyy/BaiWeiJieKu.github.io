---
layout: post
title: "算法排序"
categories: 算法
tags: 算法
author: 百味皆苦
music-id: 2602106546
---

* content
{:toc}
### 选择排序

#### 原理

- 每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。也就是：每一趟在n-i+1(i=1，2，…n-1)个记录中选取关键字最小的记录作为有序序列中第i个记录
- 基于此思想的算法主要有[简单选择排序](http://baike.so.com/doc/5992150-6205119.html)、树型选择排序和[堆排序](http://baike.so.com/doc/1008529-1066354.html)。（这里只介绍常用的简单选择排序）

#### 基本思想

- 简单选择排序的基本思想：给定数组：int[] arr={里面n个数据}；
- 第1趟排序，在待排序数据arr[1]~arr[n]中选出最小的数据，将它与arrr[1]交换；
- 第2趟，在待排序数据arr[2]~arr[n]中选出最小的数据，将它与r[2]交换；
- 以此类推，第i趟在待排序数据arr[i]~arr[n]中选出最小的数据，将它与r[i]交换，直到全部排序完成

#### 举例

- 数组 int[] arr={5,2,8,4,9,1};

- 第一趟排序： 原始数据：5  2  8  4  9  1

  最小数据1，把1放在首位，也就是1和5互换位置，

  排序结果：1  2  8  4  9  5

- 第二趟排序：

  第1以外的数据{2  8  4  9  5}进行比较，2最小，

  排序结果：1  2  8  4  9  5

- 每一趟排序获得最小数的方法：for循环进行比较，定义一个第三个变量temp，首先前两个数比较，把较小的数放在temp中，然后用temp再去跟剩下的数据比较，如果出现比temp小的数据，就用它代替temp中原有的数据

#### 代码实现

```java
//选择排序
public class SelectionSort {
    public static void main(String[] args) {
        int[] arr={1,3,2,45,65,33,12};
        System.out.println("交换之前：");
        for(int num:arr){
            System.out.print(num+" ");
        }        
        //选择排序的优化
        for(int i = 0; i < arr.length - 1; i++) {// 做第i趟排序
            int k = i;
            for(int j = k + 1; j < arr.length; j++){// 选最小的记录
                if(arr[j] < arr[k]){ 
                    k = j; //记下目前找到的最小值所在的位置
                }
            }
            //在内层循环结束，也就是找到本轮循环的最小的数以后，再进行交换
            if(i != k){  //交换a[i]和a[k]
                int temp = arr[i];
                arr[i] = arr[k];
                arr[k] = temp;
            }    
        }
        System.out.println();
        System.out.println("交换后：");
        for(int num:arr){
            System.out.print(num+" ");
        }
    }

}
```

#### 时间复杂度

- 简单选择排序的比较次数与序列的初始排序无关。 假设待排序的序列有 N 个元素，则比较次数永远都是N (N - 1) / 2。而移动次数与序列的初始排序有关。当序列正序时，移动次数最少，为 0。当序列反序时，移动次数最多，为3N (N - 1) /  2。
- 简单排序的时间复杂度为 O(N2)



### 冒泡排序

- 相邻元素前后交换、把最大的排到最后
- 时间复杂度 O(n²)

#### 思路1

- 假如有几个数字int score[] = {67, 69, 75, 88};  按照从大到小排序

- score[j] 和 score[j+1] 比较 如果 前者比后者小，把前者和后者调换顺序，两两调换后一轮下来 最小的会被排到最后去

- 每一轮j都从0开始，当i轮排序，就有最后面的i个数字因为他是最小的，所以后面的每轮都不用理他了，也就是 score.length-1-i  往后的数不用管了，如上，第一轮有4个数字 i为0 ，那么score.length-1-i  为3，也就是下标是3以后的可以不用管，3往后没有数字，所以第一轮所有的数字都要参加比较，第二轮I=1  score.length-1-i  为2 也就是说 下标2后面的 下标为3的数字不用比了，因为两两比较后，67会到 score[3]

```java
for(int i =0;i < score.length - 1;i++)
        {
            for(int j = 0;j <  score.length - 1-i;j++)// j开始等于0，
            {
                if(score[j] < score[j+1])
                {
                    int temp = score[j];
                    score[j] = score[j+1];
                    score[j+1] = temp;
                }
            }
        }
```

#### 思路2

- 用88 和 75 比较，在和69 比较 在和 67 比较，发现88是最大的，吧他排到第一位(index=0的位置)，然后i=1,也就是第二轮，就不用看下标为0的88了因为他是老大，然后接着比较。

```java
for(int i =0;i < score.length - 1;i++)
        {
            for(int j = (score.length - 2);j >= i;j--)
            {
                if(score[j] < score[j+1])
                {
                    int temp = score[j];
                    score[j] = score[j+1];
                    score[j+1] = temp;
                }
            }
        }
```

