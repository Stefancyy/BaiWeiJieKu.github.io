---
layout: post
title: "java的23种设计模式之策略模式"
categories: 设计模式
tags: 设计模式 策略模式
author: 百味皆苦
music-id: 2602106546
---

* content
{:toc}
### 注意点

- 分析项目中变化部分与不变部分
- 多用组合少用继承，用行为类组合，而不是行为的继承，更有弹性
- 设计模式有没有相应的库直接使用？有些库或框架本身就是某种设计模式设计的
- 学习设计模式最好的方式：在你的设计和以往的工程里寻找何处可以使用它们
- 设计模式的本质目的是使软件工程在维护性、扩展性、变化性、复杂度方面成O(N)



### 入门

```
在java里IO流的类设计，为什么把BufferedReader设计成：
new BufferedReader(new FileReader("F:\test.java"))；
而不是设计成：
BufferedReader extends FileReader；
然后 
new BufferedReader("F:\test.java")；
...!
```



### 原理

#### 模拟项目

```java
//从项目"模拟鸭子游戏"开始
//从OO的角度设计这个项目,鸭子超类，扩展超类：
public abstract class Duck {
    public void Quack() {
    System.out.println("~~gaga~~");
    }
    public abstract void display();
    public void swim() {
    System.out.println("~~im swim~~");
    }
}
```

```java
//1、GreenHeadDuck继承Duck ：
public class GreenHeadDuck extends Duck {
    @Override
    public void display() {
    System.out.println("**GreenHead**");
    }
}
```



#### 新需求

- 添加会飞的鸭子

```java
//OO思维里的继承方式解决方案是：
public abstract class Duck {
    ...;
    public void Fly() {
    System.out.println("~~im fly~~");
    }
}
```

- 问题来了,这个Fly让所有子类都会飞了，这是不科学的。
- **继承的问题：对类的局部改动，尤其超类的局部改动，会影响其他部分。影响会有溢出效应**

```java
//继续尝试用OO原理来解决，覆盖：
public class GreenHeadDuck extends Duck {
    ...；
    public void Fly() {
    System.out.println("~~no fly~~");
    }
}
```



#### 新需求2

- 又有新需求，石头鸭子

```java
//填坑：
public class StoneDuck extends Duck {
....
}；
```

- **超类挖的一个坑，每个子类都要来填，增加工作量，复杂度O(N^2)。不是好的设计方式**



### 用策略模式解决

- 需要新的设计方式，应对项目的扩展性，降低复杂度：
  1）分析项目变化与不变部分，提取变化部分，抽象成接口+实现；
  2）鸭子哪些功能是会根据新需求变化的？叫声、飞行...



#### 接口

```java
public interface FlyBehavior {
	void fly();
}

public interface QuackBehavior
{
	void quack();
}
```

- **好处：新增行为简单，行为类更好的复用，组合更方便。既有继承带来的复用好处，没有挖坑**

```java
public class GoodFlyBehavior implements FlyBehavior
{
	@Override
	public void fly() {
		// TODO Auto-generated method stub
		System.out.println("--GoodFly--");
	}
	
}
```

```java
public	class GaGaQuackBehavior implements QuackBehavior
{
	@Override
	public void quack() {
		// TODO Auto-generated method stub
		System.out.println("__GaGa__");
	}
	
}
```



#### 实现

```java
//重新设计的鸭子项目：
public abstract class Duck {
	//飞行接口
    FlyBehavior mFlyBehavior;
    //叫声接口
    QuackBehavior mQuackBehavior;
    public Duck() {
    }
    public void Fly() {
    	mFlyBehavior.fly();
    }
    public void Quack() {
    	mQuackBehavior.quack();
    }
    public abstract void display();
}
```

```java
//绿头鸭、石头鸭：
public class GreenHeadDuck extends Duck {
    //构造方法调用超类的构造方法
    public GreenHeadDuck() {
        //使用的时候只需要实例化想要的对象就可以了
        mFlyBehavior = new GoodFlyBehavior();
        mQuackBehavior = new GaGaQuackBehavior();
    }
    @Override
    public void display() {...}
}
```



### 总结

- **策略模式：分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里具体设**
  **定行为对象。原则就是：分离变化部分，封装接口，基于接口编程各种功能。此模式让行为**
  **算法的变化独立于算法的使用者。**

